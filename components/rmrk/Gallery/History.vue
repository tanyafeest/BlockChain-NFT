<template>
  <div class="block">
    <b-collapse
      :open="isOpen"
      class="card bordered"
      animation="slide"
      aria-id="contentIdForHistory">
      <template #trigger="props">
        <div
          class="card-header"
          role="button"
          aria-controls="contentIdForHistory">
          <p class="card-header-title">
            {{ $t('History') }}
          </p>
          <a class="card-header-icon">
            <b-icon :icon="props.open ? 'chevron-up' : 'chevron-down'">
            </b-icon>
          </a>
        </div>
      </template>
      <div class="card-content">
        <div class="content">
          <b-field>
            <b-select placeholder="Select an event" v-model="selectedEvent">
              <option value="">All</option>
              <option v-for="option in uniqType" :value="option" :key="option">
                {{ option }}
              </option>
            </b-select>
          </b-field>

          <b-table :data="data" class="mb-4" hoverable custom-row-key="ID">
            <b-table-column field="Type" label="Type" v-slot="props">
              {{ props.row.Type }}
            </b-table-column>
            <b-table-column
              cell-class="short-identity__table"
              field="From"
              label="From"
              v-slot="props">
              <nuxt-link
                :to="{
                  name: 'rmrk-u-id',
                  params: { id: props.row.From },
                }">
                <Identity :address="props.row.From" inline noOverflow />
              </nuxt-link>
            </b-table-column>
            <b-table-column
              :visible="['', 'BUY', 'SEND'].includes(currentSelectedEventType)"
              cell-class="short-identity__table"
              field="To"
              label="To"
              v-slot="props">
              <nuxt-link
                :to="{ name: 'rmrk-u-id', params: { id: props.row.To } }">
                <Identity :address="props.row.To" inline noOverflow />
              </nuxt-link>
            </b-table-column>
            <b-table-column
              cell-class="short-identity__table"
              field="Amount"
              label="Amount"
              v-slot="props">
              {{ props.row.Amount }}
            </b-table-column>
            <b-table-column
              cell-class="short-identity__table"
              field="Date"
              label="Date"
              v-slot="props">
              <a
                target="_blank"
                rel="noopener noreferrer"
                :href="getBlockUrl(props.row.Block)"
                >{{ props.row.Date }}</a
              >
            </b-table-column>
          </b-table>
        </div>
      </div>
    </b-collapse>
  </div>
</template>

<script lang="ts">
import { urlBuilderBlockNumber } from '@/utils/explorerGuide'
import formatBalance from '@/utils/formatBalance'
import ChainMixin from '@/utils/mixins/chainMixin'
import { Component, Prop, Watch, mixins } from 'nuxt-property-decorator'
import { Interaction } from '../service/scheme'
import KeyboardEventsMixin from '~/utils/mixins/keyboardEventsMixin'

const components = {
  Identity: () => import('@/components/shared/format/Identity.vue'),
}

type TableRow = {
  Type: string
  From: string
  To: string
  Amount: string
  Date: string
  Block: string
  ID: string
}

type ChartData = {
  buy: any[]
  list: any[]
}

@Component({ components })
export default class History extends mixins(ChainMixin, KeyboardEventsMixin) {
  @Prop({ type: Array }) public events!: Interaction[]
  @Prop({ type: Boolean, default: false })
  private readonly openOnDefault!: boolean

  protected data: TableRow[] = []
  protected copyTableData: TableRow[] = []
  public isOpen = this.openOnDefault
  public eventTypeTranslationMap = {}
  public currentSelectedEventType = ''

  public async created() {
    this.initKeyboardEventHandler({
      e: this.bindExpandEvents,
    })
  }

  private bindExpandEvents(event) {
    if (event.key === 'h') {
      this.isOpen = !this.isOpen
    }
  }

  get uniqType(): string[] {
    return [...new Map(this.copyTableData.map((v) => [v.Type, v])).keys()]
  }

  get selectedEvent(): string {
    return ''
  }

  set selectedEvent(event: string) {
    if (event === '') {
      // select all events
      this.currentSelectedEventType = ''
      this.data = this.copyTableData
    } else {
      this.currentSelectedEventType =
        this.eventTypeTranslationMap[JSON.stringify(event)]
      this.data = [
        ...new Set(this.copyTableData.filter((v) => v.Type === event)),
      ]
    }
  }

  protected createTable(): void {
    let prevOwner = ''
    let curPrice = '0'
    this.data = []
    this.copyTableData = []

    const chartData: ChartData = {
      buy: [],
      list: [],
    }

    for (const newEvent of this.events) {
      const event: any = {}

      // Type
      if (newEvent['interaction'] === 'MINTNFT') {
        event['Type'] = this.$t('nft.event.MINTNFT')
        event['From'] = newEvent['caller']
        event['To'] = ''
      } else if (newEvent['interaction'] === 'LIST') {
        // no need to save in eventTypeTranslationMap because there is no "To" prop
        event['Type'] = parseInt(newEvent['meta'])
          ? this.$t('nft.event.LIST')
          : this.$t('nft.event.UNLIST')
        event['From'] = newEvent['caller']
        event['To'] = ''
        prevOwner = event['From']
        curPrice = newEvent['meta']
      } else if (newEvent['interaction'] === 'SEND') {
        this.eventTypeTranslationMap[
          JSON.stringify(this.$t('nft.event.SEND'))
        ] = 'SEND'
        event['Type'] = this.$t('nft.event.SEND')
        event['From'] = newEvent['caller']
        event['To'] = newEvent['meta']
      } else if (newEvent['interaction'] === 'CONSUME') {
        event['Type'] = this.$t('nft.event.CONSUME')
        event['From'] = newEvent['caller']
        event['To'] = ''
      } else if (newEvent['interaction'] === 'BUY') {
        this.eventTypeTranslationMap[JSON.stringify(this.$t('nft.event.BUY'))] =
          'BUY'
        event['Type'] = this.$t('nft.event.BUY')
      } else event['Type'] = newEvent['interaction']

      // From
      if (!('From' in event)) event['From'] = prevOwner

      // To
      if (!('To' in event)) {
        event['To'] = newEvent['caller']
        prevOwner = event['To']
      }

      // Amount
      event['Amount'] = parseInt(curPrice)
        ? formatBalance(curPrice, this.decimals, this.unit)
        : '-'

      // Date
      const date = new Date(newEvent['timestamp'])
      event['Date'] = this.parseDate(date)

      event['Block'] = String(newEvent['blockNumber'])

      // ID for b-table: Use a unique key of your data Object for each row.
      event['ID'] = newEvent['id']

      // Push to chart data
      if (newEvent['interaction'] === 'LIST') {
        chartData.list.push([date, parseFloat(event['Amount'].substring(0, 6))])
      } else if (newEvent['interaction'] === 'BUY') {
        chartData.buy.push([date, parseFloat(event['Amount'].substring(0, 6))])
      }

      this.data.push(event)
      this.copyTableData.push(event)
    }

    this.data = this.data.reverse()
    this.copyTableData = this.copyTableData.reverse()
    this.$emit('setPriceChartData', [chartData.buy, chartData.list])
  }

  protected parseDate(date: Date): string {
    const utcDate: string = date.toUTCString()
    return utcDate.substring(4)
  }

  protected getBlockUrl(block: string): string {
    return urlBuilderBlockNumber(
      block,
      this.$store.getters['explorer/getCurrentChain'],
      'subscan'
    )
  }

  @Watch('events', { immediate: true })
  public watchEvent(): void {
    if (this.events) {
      this.createTable()
    }
  }
}
</script>
<style>
.short-identity__table {
  max-width: 50em;
  overflow: hidden;
  text-overflow: ellipsis;
}
</style>
