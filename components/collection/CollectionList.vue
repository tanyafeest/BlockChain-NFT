<template>
  <div class="collections">
    <div class="is-flex is-flex-direction-row-reverse py-5">
      <div v-show="total">{{ total }} {{ $t('items') }}</div>
    </div>
    <hr class="mt-0" />
    <a
      v-if="startPage > 1 && !isLoading && total > 0"
      class="is-flex is-justify-content-center pb-4"
      @click="reachTopHandler">
      <b-icon icon="chevron-up" />
    </a>
    <div :id="scrollContainerId" class="columns is-multiline">
      <div
        v-for="(collection, index) in collections"
        :key="collection.id"
        :class="`column ${classLayout} ${scrollItemClassName}`"
        :data-cy="`collection-index-${index}`">
        <CollectionCard :is-loading="isLoading" :collection="collection" />
      </div>
    </div>
    <EmptyResult v-if="total === 0" />
    <ScrollTopButton />
  </div>
</template>

<script lang="ts" setup>
import { Collection } from '@/components/rmrk/service/scheme'
import { SearchQuery } from '@/components/search/types'
import 'lazysizes'
import collectionListWithSearch from '@/queries/subsquid/general/collectionListWithSearch.graphql'
import { getDenyList } from '~/utils/prefix'
import shouldUpdate from '@/utils/shouldUpdate'
import EmptyResult from '@/components/common/EmptyResult.vue'
import CollectionCard from '@/components/collection/CollectionCard.vue'

interface Image extends HTMLImageElement {
  ffInitialized: boolean
}

const { urlPrefix, client } = usePrefix()
const { $store, $apollo } = useNuxtApp()

const route = useRoute()

const collections = ref<Collection[]>([])
const isLoading = ref(true)
const searchQuery = ref<SearchQuery>({
  search: route.query?.search?.toString() ?? '',
  type: route.query?.type?.toString() ?? '',
  sortBy:
    typeof route.query?.sort === 'string'
      ? [route.query?.sort]
      : route.query?.sort,
  listed: route.query?.listed?.toString() === 'true',
})

const classLayout = computed(() => $store.getters['preferences/getLayoutClass'])

const resetPage = useDebounceFn(() => {
  gotoPage(1)
}, 500)

const buildSearchParam = (): Record<string, unknown>[] => {
  const params: any[] = []

  if (searchQuery.value.search) {
    params.push({
      name_containsInsensitive: searchQuery.value.search,
    })
  }

  if (searchQuery.value.listed) {
    params.push({ nfts_some: { price_gt: '0' } })
  }

  return params
}

onBeforeMount(() => {
  fetchPageData(startPage.value)
  // setting the default layout until redesign explorer menubar: YOLO
  $store.dispatch(
    'preferences/setLayoutClass',
    'is-one-quarter-desktop is-one-third-tablet'
  )
})

const fetchPageData = async (page: number, loadDirection = 'down') => {
  if (isFetchingData.value) {
    return false
  }
  isFetchingData.value = true
  const result = await $apollo.query({
    query: collectionListWithSearch,
    client: client.value,
    variables: {
      denyList: getDenyList(urlPrefix.value),
      orderBy: searchQuery.value.sortBy,
      search: buildSearchParam(),
      listed: searchQuery.value.listed ? [{ price: { greaterThan: '0' } }] : [],
      first: first.value,
      offset: (page - 1) * first.value,
    },
  })
  await handleResult(result, loadDirection)
  isFetchingData.value = false
  return true
}

const gotoPage = (page: number) => {
  currentPage.value = page
  startPage.value = page
  endPage.value = page
  collections.value = []
  isFetchingData.value = false
  isLoading.value = true
  fetchPageData(page)
}
const {
  first,
  total,
  startPage,
  endPage,
  currentPage,
  scrollItemClassName,
  isFetchingData,
  scrollContainerId,
  reachTopHandler,
} = useListInfiniteScroll({
  gotoPage,
  fetchPageData,
})

const handleResult = async ({ data }: any, loadDirection = 'down') => {
  total.value = data.stats.totalCount
  const newCollections = data.collectionEntities.map((e: any) => ({
    ...e,
  }))

  if (loadDirection === 'up') {
    collections.value = newCollections.concat(collections.value)
  } else {
    collections.value = collections.value.concat(newCollections)
  }

  isLoading.value = false
}

watch(
  () => route.query.search,
  (val, oldVal) => {
    if (val !== oldVal) {
      resetPage()
      searchQuery.value.search = String(val) || ''
    }
  }
)

watch(
  () => route.query.sort,
  (val, oldVal) => {
    if (shouldUpdate(val, oldVal)) {
      resetPage()
      searchQuery.value.sortBy = String(val) || ''
    }
  }
)

watch(
  () => searchQuery.value,
  () => {
    resetPage()
  }
)
</script>
