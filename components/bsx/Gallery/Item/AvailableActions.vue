<template>
  <div>
    <Loader v-model="isLoading" :status="status" />
    <ActionList v-if="accountId" :actions="actions" @click="handleAction" />
    <component
      class="mb-4"
      v-if="showMeta"
      :is="showMeta"
      @input="updateMeta"
      emptyOnError />
    <SubmitButton v-if="showSubmit" @click="submit">
      {{ $t('nft.action.submit', [selectedAction]) }}
    </SubmitButton>
  </div>
</template>

<script lang="ts">
import { NFTAction } from '@/components/unique/NftUtils'
import nftById from '@/queries/nftById.graphql'
import { bsxParamResolver, getApiCall } from '@/utils/gallery/abstractCalls'
import { notificationTypes, showNotification } from '@/utils/notification'
import { unpin } from '@/utils/proxy'
import {
  actionComponent,
  getActionList,
  iconResolver,
} from '@/utils/shoppingActions'
import shouldUpdate from '@/utils/shouldUpdate'
import Connector from '@kodadot1/sub-api'
import { Component, mixins, Prop } from 'nuxt-property-decorator'
import { createTokenId } from '~/components/unique/utils'
import { isSameAccount } from '~/utils/account'
import AuthMixin from '~/utils/mixins/authMixin'
import KeyboardEventsMixin from '~/utils/mixins/keyboardEventsMixin'
import MetaTransactionMixin from '~/utils/mixins/metaMixin'
import PrefixMixin from '~/utils/mixins/prefixMixin'

const components = {
  ActionList: () => import('@/components/rmrk/Gallery/Item/ActionList.vue'),
  AddressInput: () => import('@/components/shared/AddressInput.vue'),
  BalanceInput: () => import('@/components/shared/BalanceInput.vue'),
  SubmitButton: () => import('@/components/base/SubmitButton.vue'),
  Loader: () => import('@/components/shared/Loader.vue'),
}

@Component({ components })
export default class AvailableActions extends mixins(
  PrefixMixin,
  KeyboardEventsMixin,
  MetaTransactionMixin,
  AuthMixin
) {
  @Prop(String) public currentOwnerId!: string
  @Prop() public price!: string
  @Prop() public nftId!: string
  @Prop(String) public collectionId!: string
  @Prop({ type: Array, default: () => [] }) public ipfsHashes!: string[]

  private selectedAction: NFTAction | '' = ''
  private meta: string | number = ''

  get actions() {
    return getActionList('bsx', this.isOwner, this.isAvailableToBuy)
  }

  get isOwner(): boolean {
    this.$consola.log(
      '{ currentOwnerId, accountId }',
      this.currentOwnerId,
      this.accountId
    )

    return Boolean(
      this.currentOwnerId &&
        this.accountId &&
        isSameAccount(this.currentOwnerId, this.accountId)
    )
  }

  get showSubmit() {
    return this.selectedAction && (!this.showMeta || this.metaValid)
  }

  get metaValid() {
    if (typeof this.meta === 'number') {
      return this.meta >= 0
    }

    return this.meta
  }

  get showMeta() {
    return actionComponent[this.selectedAction]
  }

  protected iconType(value: string) {
    return iconResolver[value]
  }

  protected handleAction(action: NFTAction) {
    if (shouldUpdate(action, this.selectedAction)) {
      this.selectedAction = action
    } else {
      this.selectedAction = NFTAction.NONE
      this.meta = ''
    }
  }

  get isAvailableToBuy(): boolean {
    const { price, accountId } = this
    return Boolean(accountId && Number(price) > 0)
  }

  private handleSelect(value: NFTAction) {
    this.selectedAction = value
    this.meta = ''
  }

  get isConsume() {
    return this.selectedAction === 'CONSUME'
  }

  protected updateMeta(value: string | number) {
    this.$consola.log(typeof value, value)
    this.meta = value
  }

  protected async checkBuyBeforeSubmit() {
    const nft = await this.$apollo.query({
      query: nftById,
      variables: {
        id: this.nftId,
      },
    })

    const {
      data: { nFTEntity },
    } = nft
    // DEV: nFTEntity.price == 0 is a feature to handle the buy flow
    if (
      nFTEntity.currentOwner !== this.currentOwnerId ||
      nFTEntity.burned ||
      nFTEntity.price == 0 ||
      nFTEntity.price !== this.price
    ) {
      showNotification(
        `[RMRK::${this.selectedAction}] Owner changed or NFT does not exist`,
        notificationTypes.warn
      )
      throw new ReferenceError('NFT has changed')
    }
  }

  protected async submit() {
    const { api } = Connector.getInstance()
    this.initTransactionLoader()

    try {
      if (!this.selectedAction || !this.collectionId) {
        this.$consola.log('EvalError', this.selectedAction, this.collectionId)
        throw new EvalError('Action or Collection not found')
      }

      showNotification(`[${this.selectedAction}] ${this.nftId}`)
      let cb = getApiCall(api, this.urlPrefix, this.selectedAction)
      let arg: any[] = this.getArgs()

      this.howAboutToExecute(
        this.accountId,
        cb,
        arg,
        (blockNumber: string) => {
          showNotification(blockNumber, notificationTypes.info)
          if (this.isConsume) {
            this.unpinNFT()
          }

          showNotification(
            `[${this.selectedAction}] ${this.nftId}`,
            notificationTypes.success
          )
          this.$emit('change')
          this.selectedAction = ''
        },
        () => {
          this.selectedAction = ''
        }
      )
    } catch (e) {
      showNotification(`[ERR] ${e}`, notificationTypes.danger)
      this.$consola.error(e)
      this.isLoading = false
    }
  }

  protected getArgs(): any[] {
    const { selectedAction, collectionId, nftId, currentOwnerId, meta } = this

    console.log(collectionId, nftId)

    return bsxParamResolver(
      createTokenId(collectionId, nftId),
      selectedAction,
      meta,
      currentOwnerId
    )
  }

  protected unpinNFT() {
    this.ipfsHashes.forEach(async (hash) => {
      if (hash) {
        try {
          await unpin(hash)
        } catch (e) {
          this.$consola.warn(`[ACTIONS] Cannot Unpin ${hash} because: ${e}`)
        }
      }
    })
  }
}
</script>
